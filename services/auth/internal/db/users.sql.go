// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminHardDeleteUser = `-- name: AdminHardDeleteUser :exec

DELETE FROM users
WHERE user_id = $1
`

// ============================================
// ADMIN ONLY
// ============================================
func (q *Queries) AdminHardDeleteUser(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, adminHardDeleteUser, userID)
	return err
}

const bulkDeactivateUsers = `-- name: BulkDeactivateUsers :exec

UPDATE users
SET
    is_active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = ANY($1::UUID[])
`

// ============================================
// BATCH OPERATIONS
// ============================================
func (q *Queries) BulkDeactivateUsers(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, bulkDeactivateUsers, dollar_1)
	return err
}

const checkUserExists = `-- name: CheckUserExists :one
SELECT COUNT(*) > 0
FROM users
WHERE email = $1
`

func (q *Queries) CheckUserExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExists, email)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*)
FROM users
WHERE
    ($1::BOOLEAN IS NULL OR is_active = $1)
    AND (
        $2 IS NULL OR
        email ILIKE '%' || $2 || '%' OR
        name ILIKE '%' || $2 || '%'
    )
`

type CountUsersParams struct {
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
	Search   interface{} `db:"search" json:"search"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, arg.IsActive, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    email,
    password,
    name
) VALUES (
    $1, $2, $3
)
RETURNING
    user_id,
    email,
    name,
    created_at,
    is_active
`

type CreateUserParams struct {
	Email    string      `db:"email" json:"email"`
	Password string      `db:"password" json:"password"`
	Name     pgtype.Text `db:"name" json:"name"`
}

type CreateUserRow struct {
	UserID    pgtype.UUID      `db:"user_id" json:"user_id"`
	Email     string           `db:"email" json:"email"`
	Name      pgtype.Text      `db:"name" json:"name"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	IsActive  pgtype.Bool      `db:"is_active" json:"is_active"`
}

// ============================================
// USER CREATION
// ============================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Password, arg.Name)
	var i CreateUserRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.IsActive,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :exec

UPDATE users
SET
    is_active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

// ============================================
// USER STATUS MANAGEMENT
// ============================================
func (q *Queries) DeactivateUser(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateUser, userID)
	return err
}

const getDuplicateEmails = `-- name: GetDuplicateEmails :many

SELECT
    email,
    COUNT(*) AS count
FROM users
GROUP BY email
HAVING COUNT(*) > 1
`

type GetDuplicateEmailsRow struct {
	Email string `db:"email" json:"email"`
	Count int64  `db:"count" json:"count"`
}

// ============================================
// DATA INTEGRITY
// ============================================
func (q *Queries) GetDuplicateEmails(ctx context.Context) ([]GetDuplicateEmailsRow, error) {
	rows, err := q.db.Query(ctx, getDuplicateEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDuplicateEmailsRow{}
	for rows.Next() {
		var i GetDuplicateEmailsRow
		if err := rows.Scan(&i.Email, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT
    user_id,
    email,
    password,
    name,
    created_at,
    updated_at,
    is_active
FROM users
WHERE email = $1
  AND is_active = true
LIMIT 1
`

// ============================================
// USER AUTHENTICATION QUERIES
// ============================================
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    user_id,
    email,
    password,
    name,
    created_at,
    updated_at,
    is_active
FROM users
WHERE user_id = $1
  AND is_active = true
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, userID pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getUserForValidation = `-- name: GetUserForValidation :one
SELECT
    user_id,
    email,
    is_active
FROM users
WHERE user_id = $1
  AND is_active = true
LIMIT 1
`

type GetUserForValidationRow struct {
	UserID   pgtype.UUID `db:"user_id" json:"user_id"`
	Email    string      `db:"email" json:"email"`
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
}

func (q *Queries) GetUserForValidation(ctx context.Context, userID pgtype.UUID) (GetUserForValidationRow, error) {
	row := q.db.QueryRow(ctx, getUserForValidation, userID)
	var i GetUserForValidationRow
	err := row.Scan(&i.UserID, &i.Email, &i.IsActive)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one

SELECT
    COUNT(*)                                AS total_users,
    COUNT(*) FILTER (WHERE is_active)       AS active_users,
    COUNT(*) FILTER (WHERE NOT is_active)   AS inactive_users,
    COUNT(*) FILTER (
        WHERE created_at >= NOW() - INTERVAL '24 hours'
    ) AS new_users_24h,
    COUNT(*) FILTER (
        WHERE created_at >= NOW() - INTERVAL '7 days'
    ) AS new_users_7d
FROM users
`

type GetUserStatsRow struct {
	TotalUsers    int64 `db:"total_users" json:"total_users"`
	ActiveUsers   int64 `db:"active_users" json:"active_users"`
	InactiveUsers int64 `db:"inactive_users" json:"inactive_users"`
	NewUsers24h   int64 `db:"new_users_24h" json:"new_users_24h"`
	NewUsers7d    int64 `db:"new_users_7d" json:"new_users_7d"`
}

// ============================================
// ANALYTICS
// ============================================
func (q *Queries) GetUserStats(ctx context.Context) (GetUserStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserStats)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.ActiveUsers,
		&i.InactiveUsers,
		&i.NewUsers24h,
		&i.NewUsers7d,
	)
	return i, err
}

const getUsersByDateRange = `-- name: GetUsersByDateRange :many
SELECT
    user_id,
    email,
    name,
    created_at,
    is_active
FROM users
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
`

type GetUsersByDateRangeParams struct {
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `db:"created_at_2" json:"created_at_2"`
}

type GetUsersByDateRangeRow struct {
	UserID    pgtype.UUID      `db:"user_id" json:"user_id"`
	Email     string           `db:"email" json:"email"`
	Name      pgtype.Text      `db:"name" json:"name"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	IsActive  pgtype.Bool      `db:"is_active" json:"is_active"`
}

func (q *Queries) GetUsersByDateRange(ctx context.Context, arg GetUsersByDateRangeParams) ([]GetUsersByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getUsersByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByDateRangeRow{}
	for rows.Next() {
		var i GetUsersByDateRangeRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Name,
			&i.CreatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveUsers = `-- name: ListActiveUsers :many
SELECT
    user_id,
    email,
    name,
    created_at
FROM users
WHERE is_active = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListActiveUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListActiveUsersRow struct {
	UserID    pgtype.UUID      `db:"user_id" json:"user_id"`
	Email     string           `db:"email" json:"email"`
	Name      pgtype.Text      `db:"name" json:"name"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) ListActiveUsers(ctx context.Context, arg ListActiveUsersParams) ([]ListActiveUsersRow, error) {
	rows, err := q.db.Query(ctx, listActiveUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveUsersRow{}
	for rows.Next() {
		var i ListActiveUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many

SELECT
    user_id,
    email,
    name,
    created_at,
    is_active
FROM users
WHERE
    ($3::BOOLEAN IS NULL OR is_active = $3)
    AND (
        $4 IS NULL OR
        email ILIKE '%' || $4 || '%' OR
        name ILIKE '%' || $4 || '%'
    )
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit    int32       `db:"limit" json:"limit"`
	Offset   int32       `db:"offset" json:"offset"`
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
	Search   interface{} `db:"search" json:"search"`
}

type ListUsersRow struct {
	UserID    pgtype.UUID      `db:"user_id" json:"user_id"`
	Email     string           `db:"email" json:"email"`
	Name      pgtype.Text      `db:"name" json:"name"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	IsActive  pgtype.Bool      `db:"is_active" json:"is_active"`
}

// ============================================
// LISTING & PAGINATION
// ============================================
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Name,
			&i.CreatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reactivateUser = `-- name: ReactivateUser :exec
UPDATE users
SET
    is_active = true,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

func (q *Queries) ReactivateUser(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, reactivateUser, userID)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET
    email = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
  AND is_active = true
RETURNING
    user_id,
    email,
    updated_at
`

type UpdateUserEmailParams struct {
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
	Email  string      `db:"email" json:"email"`
}

type UpdateUserEmailRow struct {
	UserID    pgtype.UUID      `db:"user_id" json:"user_id"`
	Email     string           `db:"email" json:"email"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (UpdateUserEmailRow, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.UserID, arg.Email)
	var i UpdateUserEmailRow
	err := row.Scan(&i.UserID, &i.Email, &i.UpdatedAt)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET
    password = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
  AND is_active = true
`

type UpdateUserPasswordParams struct {
	UserID   pgtype.UUID `db:"user_id" json:"user_id"`
	Password string      `db:"password" json:"password"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.UserID, arg.Password)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one

UPDATE users
SET
    name = COALESCE($2, name),
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
  AND is_active = true
RETURNING
    user_id,
    email,
    name,
    updated_at
`

type UpdateUserProfileParams struct {
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
	Name   pgtype.Text `db:"name" json:"name"`
}

type UpdateUserProfileRow struct {
	UserID    pgtype.UUID      `db:"user_id" json:"user_id"`
	Email     string           `db:"email" json:"email"`
	Name      pgtype.Text      `db:"name" json:"name"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// ============================================
// USER PROFILE UPDATES
// ============================================
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (UpdateUserProfileRow, error) {
	row := q.db.QueryRow(ctx, updateUserProfile, arg.UserID, arg.Name)
	var i UpdateUserProfileRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.UpdatedAt,
	)
	return i, err
}
